---
title: The Useless useCallback
url: /writing/the-useless-usecallback
publishedAt: 2025-08-05T03:00:00Z
updatedAt: 2025-08-05T03:00:00Z
description: This is a translation of the original article from TkDodo
keywords: react, javascript, frontend, hooks
---

Esse post faz parte do blog [TkDodo](https://tkdodo.eu/blog/the-useless-use-callback) e √© uma tradu√ß√£o para o portugu√™s.

## Por que memorizar?

Geralmente, existem apenas duas raz√µes para criar uma vers√£o memoizada de uma fun√ß√£o com `useCallback` ou um valor com `useMemo`:

### Otimiza√ß√£o de performance

Algo est√° lento, e lentid√£o geralmente √© ruim. Normalmente, n√≥s o deixariamos mais r√°pido, mas nem sempre podemos fazer isso. Em vez disso, podemos tentar fazer essa coisa lenta com menos frequ√™ncia.

No React, na maioria das vezes, a coisa lenta √© re-renderiza√ß√£o de uma sub-√°rvore, ent√£o gostar√≠amos de evitar isso se acharmos que "n√£o √© necess√°rio".

√â por isso que as vezes envolvemos componentes com um `React.memo`, o que √© uma batalha perdida que na maioria das vezes n√£o vale a pena lutar, mas, ainda assim, √© algo que existe.

Se passarmos uma fun√ß√£o ou um valor n√£o primitivo para um componente memoizado, precisamos garantir que as refer√™ncias a eles sejam **est√°veis**. Isso acontece porque o React compara as props de um componente memoizado com `Object.is` para verificar se pode pular a renderiza√ß√£o dessa sub-√°rvore. Portanto, se a refer√™ncia n√£o for est√°vel, por exemplo, porque √© recriada a cada renderiza√ß√£o, nossa memoiza√ß√£o "quebra":

```tsx
function Meh() {
  return (
    <MemoizedComponent
      value={{ hello: 'world' }}
      onChange={result => console.log('result')}
    />
  );
}

function Okay() {
  const value = useMemo(() => ({ hello: 'world' }), []);
  const onChange = useCallback(result => console.log(result), []);

  return <MemoizedComponent value={value} onChange={onChange} />;
}
```

Sim, √†s vezes o c√°lculo dentro do pr√≥prio `useMemo` √© lento, e n√≥s o memoizamos para evitar esses rec√°lculos. Essas chamadas de `useMemo` tamb√©m s√£o perfeitamente aceit√°veis, mas n√£o acho que sejam a maioria dos casos de uso.

### Evitar que efeitos sejam disparados com muita frequ√™ncia

Se n√£o for passado como uma prop para um componente memoizado, √© prov√°vel que nosso valor memoizado seja eventualmente passado como uma depend√™ncia para um efeito (√†s vezes atrav√©s de algumas camadas de hooks customizados).

As depend√™ncias do efeito seguem as mesmas regras do `React.memo` - elas s√£o comparadas uma a uma com `Object.is` para ver se o efeito precisa ser re-executado. Portanto, se n√£o formos cuidadosos ao memoizar as depend√™ncias do efeito, ele pode ser executado a cada renderiza√ß√£o.

Agora, se pensarmos um pouco, podemos notar que os dois cen√°rios s√£o, na verdade, exatamente os mesmos. Eles tentam evitar que algo aconte√ßa, mantendo a mesma refer√™ncia por meio de cache. Portanto, a raz√£o comum para aplicar `useCallback` ou `useMemo` √© apenas:

**Preciso de estabilidade referencial**

Acho que todos n√≥s poder√≠amos usar um pouco de estabilidade em nossas vidas, ent√£o quais s√£o os casos em que lutar pela estabilidade √©, como eu disse inicialmente, in√∫til?

## Sem memo - sem ganhos de performance

Vamos pegar o exemplo acima e mudar uma coisinha:

```tsx
function Okay() {
  const value = useMemo(() => ({ hello: 'world' }), []);
  const onChange = useCallback(result => console.log(result), []);

  return <Component value={value} onChange={onChange} />;
}
```

Consegue ver a diferen√ßa? Exatamente - n√£o estamos mais passando `value` e `onChange` para um componente memoizado - √© apenas um componente funcional regular do React agora. Vejo isso acontecer muito quando os valores s√£o, no final, passados para os componentes nativos do React:

```tsx
function MyButton() {
  const onClick = useCallback(
    event => console.log(event.currentTarget.value),
    [],
  );

  return <button onClick={onClick} />;
}
```

Aqui, memoizar `onClick` n√£o resulta em nada, j√° que o `button` n√£o se importa se `onClick` √© referencialmente est√°vel ou n√£o.

<Callout>
<strong>N√£o resulta em nada?</strong>
<p>"N√£o resulta em nada" √© um pouco errado, porque √© claro que algo est√° acontecendo aqui por baixo dos panos. O React ter√° que criar um cache para manter a fun√ß√£o `onClick` por perto. Ele ter√° que acompanhar as depend√™ncias e compar√°-las a cada renderiza√ß√£o. A fun√ß√£o inline passada para o `useCallback` tamb√©m ser√° recriada a cada renderiza√ß√£o, s√≥ que ser√° descartada imediatamente se a vers√£o em cache for retornada.</p>
<p>Ent√£o, isso tecnicamente cria um pouco mais de sobrecarga internamente. N√£o quero focar muito nisso, porque essa "sobrecarga" n√£o √© o problema.</p>
</Callout>

Ent√£o, se o seu componente customizado n√£o for memoizado, espera-se que ele tamb√©m n√£o se importe com a estabilidade referencial!

Espere a√≠ - mas e se esse `Componente` usar essas props internamente para um `useEffect`, ou para criar outros valores memoizados que s√£o passados para um componente memoizado e assim para seus pr√≥prios filhos? Eu posso quebrar algo se remover essas memoiza√ß√µes agora!

Isso nos leva diretamente ao segundo ponto:

## Usando props como depend√™ncias

Adicionar `props` n√£o primitivas que voc√™ recebe em seu componente a arrays de depend√™ncia internos **raramente √© correto**, porque este componente n√£o tem controle sobre a estabilidade referencial dessas props. Um exemplo comum √©:

```tsx
function OhNo({ onChange }) {
  const handleChange = useCallback(
    (e: React.ChangeEvent) => {
      trackAnalytics('changeEvent', e);
      onChange?.(e);
    },
    [onChange],
  );

  return <SomeMemoizedComponent onChange={handleChange} />;
}
```

Este `useCallback` √© provavelmente in√∫til, ou, na melhor das hip√≥teses, depende de como os desenvolvedores usar√£o este componente. Muito provavelmente, h√° um lado da chamada que apenas invoca uma fun√ß√£o inline:

```tsx
<OhNo onChange={() => props.doSomething()} />
```

Este √© um uso inocente. N√£o h√° nada de errado com isso. Na verdade, √© √≥timo. Ele co-localiza o que quer fazer com o event handler. Evita extrair coisas para o topo do arquivo com o nome complicado tipo `handleChange`.

A √∫nica maneira de um desenvolvedor que escreve este c√≥digo saber que ele est√° quebrando alguma memoiza√ß√£o √© se ele ver o c√≥digo do componente para ver como as props est√£o sendo usadas. Isso √© horr√≠vel.

Outras maneiras de corrigir isso incluem uma pol√≠tica de "memoizamos tudo o tempo todo", ou ter uma conven√ß√£o de nomenclatura estritamente aplicada, como um prefixo "mustBeMemoized" para props que precisam ser referencialmente est√°veis. Ambas n√£o s√£o √≥timas.

### Um Exemplo da Vida Real

Como estou trabalhando na [base de c√≥digo do Sentry](https://github.com/getsentry/sentry) agora, que √© de c√≥digo aberto üéâ, tenho muitos casos reais para vincular. Uma situa√ß√£o que encontrei √© no nosso hook customizado `useHotkeys`. As partes importantes se parecem com algo assim:

```tsx
export function useHotkeys(hotkeys: Hotkey[]): {
  const onKeyDown = useCallback(() => ..., [hotkeys])

  useEffect(() => {
    document.addEventListener('keydown', onKeyDown)

    return () => {
      document.removeEventListener('keydown', onKeyDown)
    }
  }, [onKeyDown])
}
```

Este hook customizado recebe um Array de `hotkeys` como entrada e, em seguida, cria uma fun√ß√£o `onKeyDown` memoizada, que √© passada para um effect. A fun√ß√£o √© claramente memoizada para evitar que o efeito seja disparado com muita frequ√™ncia, mas o fato de `hotkeys` ser um Array significa que os consumidores **devem memoiz√°-los manualmente**.

Eu busquei todos os usos de `useHotkeys` e fiquei positivamente surpreso ao ver que todos, [exceto um](https://github.com/getsentry/sentry/blob/a80e48ce659dea903e4d9594420cde019b33b757/static/app/views/issueDetails/streamline/hooks/useCopyIssueDetails.tsx#L161-L172), memoizam a entrada. No entanto, isso n√£o √© tudo, porque se olharmos mais a fundo, as coisas tendem a ficar piores. Vamos pegar, por exemplo, [este uso](https://github.com/getsentry/sentry/blob/97130081986520a2035882249b5670189d859dda/static/app/components/events/eventTagsAndScreenshot/screenshot/modal.tsx#L86):

```tsx
const paginateHotkeys = useMemo(() => {
  return [
    { match: 'right', callback: () => paginateItems(1) },
    { match: 'left', callback: () => paginateItems(-1) },
  ];
}, [paginateItems]);

useHotkeys(paginateHotkeys);
```

`useHotKeys` passa `paginateHotkeys`, que √© memoizado, mas depende de `paginateItems`. De onde vem isso? Bem, √© outro `useCallback` que depende de `screenshots` e `currentAttachmentIndex`. E de onde v√™m as `screenshots`?

```tsx
const screenshots = attachments.filter(({ name }) =>
  name.includes('screenshot'),
);
```

√â uma fun√ß√£o `attachments.filter` n√£o memoizada, que sempre criar√° um novo Array, o que quebra todas as outras memoiza√ß√µes que vimos anteriormente. Com isso, todas elas se tornam in√∫teis. `paginateItems`, `paginateHotkeys`, `onKeyDown`. Tr√™s memoiza√ß√µes que t√™m a garantia de serem re-executadas a cada renderiza√ß√£o, como se n√£o as tiv√©ssemos escrito!

Espero que este exemplo mostre por que sou apaixonadamente contra a aplica√ß√£o de memoiza√ß√µes. Na minha experi√™ncia, quebra com muita frequ√™ncia. N√£o vale a pena. E adiciona tanta sobrecarga e complexidade a todo o c√≥digo que temos que ler.

A corre√ß√£o aqui n√£o √© memoizar `screenshots` tamb√©m. Isso apenas transferiria a responsabilidade para `attachments`, que √© uma prop para o componente. Em todos os tr√™s locais de chamada, estar√≠amos a pelo menos dois n√≠veis de dist√¢ncia de onde a memoiza√ß√£o real √© necess√°ria (`useHotkeys`). Isso se torna um pesadelo para navegar e, eventualmente, ningu√©m ousar√° remover uma √∫nica memoiza√ß√£o porque n√£o podemos saber o que ela est√° realmente fazendo.

Se for o caso, temos que terceirizar tudo isso para um compilador, o que √© √≥timo quando o tivermos funcionando em todos os lugares. Mas at√© l√°, temos que encontrar padr√µes para contornar a limita√ß√£o de precisar da estabilidade referencial:

## O Padr√£o "Latest Ref"

Eu escrevi [sobre esse padr√£o antes](https://tkdodo.eu/blog/refs-events-and-escape-hatches#the-latest-ref); o que fazemos √© basicamente armazenar o valor ao qual queremos obter acesso imperativo dentro de nosso effect em uma `ref`, e ent√£o atualizar o valor com outro effect que √© executado propositalmente a cada renderiza√ß√£o:

```tsx
export function useHotkeys(hotkeys: Hotkey[]): {
  const hotkeysRef = useRef(hotkeys)

  useEffect(() => {
    hotkeysRef.current = hotkeys
  })

  const onKeyDown = useCallback(() => ..., [])

  useEffect(() => {
    document.addEventListener('keydown', onKeyDown)

    return () => {
      document.removeEventListener('keydown', onKeyDown)
    }
  }, [])
}
```

Ent√£o, podemos usar o `hotkeysRef` dentro do nosso efeito sem ter que adicion√°-lo ao array de depend√™ncias e sem ter que nos preocupar com [ stale closures ](https://tkdodo.eu/blog/hooks-dependencies-and-stale-closures) que poder√≠amos encontrar ao ignorar o linter.

O React Query tamb√©m usa esse padr√£o para acompanhar as op√ß√µes mais recentes que est√£o sendo passadas, por exemplo, no `PersistQueryClientProvider` ou no `useMutationState`, ent√£o eu diria que √© um padr√£o testado e aprovado. Imagine se a biblioteca precisasse que os consumidores memoizassem suas op√ß√µes manualmente...

## UseEffectEvent

Mais boas not√≠cias: o React percebeu que muitas vezes precisamos de acesso imperativo ao valor mais recente de algo durante um efeito reativo sem cham√°-lo explicitamente, ent√£o eles v√£o adicionar esse padr√£o para exatamente este caso de uso como uma primitiva de primeira classe, [useEffectEvent](https://react.dev/learn/separating-events-from-effects#declaring-an-effect-event).

Assim que for lan√ßado, podemos refatorar o c√≥digo para:

```tsx
export function useHotkeys(hotkeys: Hotkey[]): {
  const onKeyDown = useEffectEvent(() => ...)

  useEffect(() => {
    document.addEventListener('keydown', onKeyDown)

    return () => {
      document.removeEventListener('keydown', onKeyDown)
    }
  }, [])
}
```

Isso tornaria `onKeyDown` n√£o reativo, ele seria capaz de "ver" sempre os valores mais recentes de `hotkeys`, e seria referencialmente est√°vel entre as renderiza√ß√µes. O melhor de todos os mundos, sem ter que escrever um √∫nico `useCallback` ou `useMemo` in√∫til.

That's it for today. Feel free to reach out to me on [bluesky ü¶ã](https://bsky.app/profile/tkdodo.eu)
